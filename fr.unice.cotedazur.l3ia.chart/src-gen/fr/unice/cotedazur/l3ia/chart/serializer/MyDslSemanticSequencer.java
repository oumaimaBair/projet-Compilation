/*
 * generated by Xtext 2.25.0
 */
package fr.unice.cotedazur.l3ia.chart.serializer;

import com.google.inject.Inject;
import fr.unice.cotedazur.l3ia.chart.services.MyDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import tpNote.BinaryBooleanExp;
import tpNote.Constant;
import tpNote.File;
import tpNote.Graph;
import tpNote.HTMLFile;
import tpNote.Programme;
import tpNote.TpNotePackage;
import tpNote.colRef;
import tpNote.extractedData;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TpNotePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TpNotePackage.BINARY_BOOLEAN_EXP:
				sequence_BinaryBooleanExp(context, (BinaryBooleanExp) semanticObject); 
				return; 
			case TpNotePackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case TpNotePackage.FILE:
				sequence_File(context, (File) semanticObject); 
				return; 
			case TpNotePackage.GRAPH:
				sequence_Graph(context, (Graph) semanticObject); 
				return; 
			case TpNotePackage.HTML_FILE:
				sequence_HTMLFile(context, (HTMLFile) semanticObject); 
				return; 
			case TpNotePackage.PROGRAMME:
				sequence_Programme(context, (Programme) semanticObject); 
				return; 
			case TpNotePackage.COL_REF:
				sequence_colRef(context, (colRef) semanticObject); 
				return; 
			case TpNotePackage.EXTRACTED_DATA:
				sequence_extractedData(context, (extractedData) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     filterCondition returns BinaryBooleanExp
	 *     BinaryBooleanExp returns BinaryBooleanExp
	 *
	 * Constraint:
	 *     (lhs=filterCondition operator=comOperator rhs=filterCondition)
	 */
	protected void sequence_BinaryBooleanExp(ISerializationContext context, BinaryBooleanExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TpNotePackage.Literals.BINARY_BOOLEAN_EXP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TpNotePackage.Literals.BINARY_BOOLEAN_EXP__LHS));
			if (transientValues.isValueTransient(semanticObject, TpNotePackage.Literals.BINARY_BOOLEAN_EXP__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TpNotePackage.Literals.BINARY_BOOLEAN_EXP__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, TpNotePackage.Literals.BINARY_BOOLEAN_EXP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TpNotePackage.Literals.BINARY_BOOLEAN_EXP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryBooleanExpAccess().getLhsFilterConditionParserRuleCall_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBinaryBooleanExpAccess().getOperatorComOperatorEnumRuleCall_2_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getBinaryBooleanExpAccess().getRhsFilterConditionParserRuleCall_3_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     filterCondition returns Constant
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     (type=typeDonnees? value=EString?)
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     File returns File
	 *
	 * Constraint:
	 *     (path=EString? delimiter=EString? keep+=extractedData keep+=extractedData*)
	 */
	protected void sequence_File(ISerializationContext context, File semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Graph returns Graph
	 *
	 * Constraint:
	 *     (type=typeGraph? title=EString? xAxis=[extractedData|EString] (yAxis+=[extractedData|EString] yAxis+=[extractedData|EString]*)?)
	 */
	protected void sequence_Graph(ISerializationContext context, Graph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HTMLFile returns HTMLFile
	 *
	 * Constraint:
	 *     (graph+=Graph graph+=Graph*)
	 */
	protected void sequence_HTMLFile(ISerializationContext context, HTMLFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Programme returns Programme
	 *
	 * Constraint:
	 *     (input=File (filtercondition+=filterCondition filtercondition+=filterCondition*)? output=HTMLFile)
	 */
	protected void sequence_Programme(ISerializationContext context, Programme semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     filterCondition returns colRef
	 *     colRef returns colRef
	 *
	 * Constraint:
	 *     extracteddata=[extractedData|EString]?
	 */
	protected void sequence_colRef(ISerializationContext context, colRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     extractedData returns extractedData
	 *
	 * Constraint:
	 *     (name=EString typeData=typeDonnees? index=EInt?)
	 */
	protected void sequence_extractedData(ISerializationContext context, extractedData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
